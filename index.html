<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fiyat Takipçisi (AI Analizli)</title>

    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script src="https://www.gstatic.com/firebasejs/10.5.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.5.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.5.2/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.5.2/firebase-functions-compat.js"></script>

    <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>

    <style>
        :root {
            --bg-primary: #131722; --bg-secondary: #1e222d; --bg-tertiary: #2a2e39;
            --border-color: #424651; --text-primary: #d1d4dc; --text-secondary: #8c92a2;
            --accent-blue: #2962ff; --accent-green: #26a69a; --accent-red: #ef5350; --accent-yellow: #f59e0b;
            --strong-buy: #00bfa5; --buy: #26a69a; --hold: #8c92a2; --sell: #ef5350; --strong-sell: #d50000;
            --value-positive: #26de81; --value-negative: #ff4757;
        }
        html { scroll-behavior: smooth; }
        body {
            font-family: 'Inter', sans-serif; margin: 0; background-color: var(--bg-primary); color: var(--text-primary);
            overflow-x: hidden; -webkit-tap-highlight-color: transparent;
        }
        body.modal-open { overflow: hidden; }
        .page { min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding: 10px; box-sizing: border-box; }
        .login-container { background: var(--bg-secondary); padding: 40px; border-radius: 12px; border: 1px solid var(--border-color); width: 100%; max-width: 400px; text-align: center; margin-top: 10vh; }
        .login-container h1 { color: var(--text-primary); font-size: 2rem; margin-bottom: 10px; display: flex; align-items: center; justify-content: center; gap: 10px; }
        .login-container h1 .fas { color: var(--accent-yellow); }
        .login-container p { margin-bottom: 30px; color: var(--text-secondary); }
        .input-group { margin-bottom: 20px; text-align: left; }
        .input-group label { display: block; margin-bottom: 8px; font-weight: 500; font-size: 0.9rem; color: var(--text-secondary); }
        .login-container input { width: 100%; padding: 12px 15px; border: 1px solid var(--border-color); background-color: var(--bg-tertiary); color: var(--text-primary); border-radius: 8px; font-size: 1rem; box-sizing: border-box; }
        .button-group { display: flex; gap: 10px; margin-top: 25px; }
        .login-container button { flex-grow: 1; background-color: var(--accent-blue); color: white; border: none; padding: 12px 20px; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: 600; }
        #error-message { color: var(--accent-red); margin-top: 15px; font-weight: 500; min-height: 20px; }
        .tracker-container { width: 100%; max-width: 1200px; margin: 0 auto; background-color: var(--bg-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--border-color); }
        .app-header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); margin-bottom: 20px; flex-wrap: wrap; gap: 15px; }
        .app-header .header-left h1 { color: var(--text-primary); font-size: 1.8rem; margin: 0; display: flex; align-items: center; gap: 12px; }
        .app-header .header-left h1 .fas { color: var(--accent-yellow); }
        .app-header .header-right { display: flex; align-items: center; gap: 10px; }
        .app-header .main-actions button { background-color: var(--bg-tertiary); color: var(--text-secondary); padding: 8px 16px; font-size: 0.9rem; border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; }
        .user-menu { position: relative; }
        #userMenuBtn { background-color: var(--bg-tertiary); color: var(--text-primary); padding: 8px 12px; display: flex; align-items: center; gap: 8px; border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; }
        .dropdown-content { display: none; position: absolute; right: 0; background-color: var(--bg-secondary); min-width: 200px; box-shadow: 0 8px 16px rgba(0,0,0,0.4); z-index: 100; border-radius: 8px; border: 1px solid var(--border-color); overflow: hidden; }
        .dropdown-content a { color: var(--text-primary); padding: 12px 16px; text-decoration: none; display: flex; align-items: center; gap: 10px; font-size: 0.95rem; }
        .dropdown-content a:hover { background-color: var(--bg-tertiary); }
        .user-menu:hover .dropdown-content { display: block; }
        .add-asset-bar { display: flex; gap: 10px; margin-bottom: 25px; }
        .add-asset-bar input { flex-grow: 1; padding: 12px 15px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 1rem; background-color: var(--bg-tertiary); color: var(--text-primary); }
        .add-asset-bar button { padding: 12px 20px; background-color: var(--accent-blue); border-radius: 8px; border: none; color: white; cursor: pointer; }
        .table-controls { display: flex; justify-content: flex-end; margin-bottom: 10px; }
        .table-controls button { background-color: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-color); padding: 8px 16px; border-radius: 8px; cursor: pointer; }
        .table-wrapper { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; font-size: 0.95rem; }
        th, td { padding: 14px 10px; text-align: left; border-bottom: 1px solid var(--border-color); white-space: nowrap; }
        th { color: var(--text-secondary); font-weight: 500; position: sticky; top: 0; background-color: var(--bg-secondary); z-index: 1; }
        th.sortable { cursor: pointer; }
        th.sortable:hover { color: var(--text-primary); }
        th .sort-indicator { margin-left: 8px; opacity: 0.5; transition: opacity 0.2s; display: inline-block; width: 1em; text-align: center;}
        th.asc .sort-indicator, th.desc .sort-indicator { opacity: 1; }
        th.asc .sort-indicator::before { content: '▲'; }
        th.desc .sort-indicator::before { content: '▼'; }
        td { color: var(--text-primary); }
        .asset-cell { font-weight: 600; color: #64b5f6; cursor: pointer; }
        .asset-cell:hover { text-decoration: underline; }
        .asset-cell .symbol { display:none; }
        .drag-handle-col { width: 20px; padding: 0 10px; }
        .drag-handle-col.hidden, #cryptoPriceTable .drag-handle-col.hidden { display: none; }
        .drag-handle { cursor: grab; padding: 0 10px; color: #9ca3af; }
        tr:hover td { background-color: var(--bg-tertiary); }
        .positive { color: var(--accent-green); }
        .positive-high { font-weight: 600; }
        .positive-low { font-weight: 600; }
        .negative { color: var(--accent-red); font-weight: 600; }
        .clickable-pct { cursor: pointer; text-decoration: underline; text-decoration-style: dotted; text-decoration-color: var(--text-secondary); }
        .update-time { text-align: center; margin: 20px 0 10px 0; color: var(--text-secondary); font-size: 0.85rem; }
        .action-btn { background-color: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 1rem; }
        .action-btn:hover { color: var(--accent-red); }
        .loading { display: inline-block; width: 16px; height: 16px; border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; border-top-color: white; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease; }
        .modal-overlay.show { opacity: 1; visibility: visible; }
        .panel { position: fixed; top: 50%; left: 50%; background-color: var(--bg-secondary); padding: 0; border-radius: 12px; border: 1px solid var(--border-color); z-index: 1001; width: clamp(300px, 90vw, 650px); max-height: 90vh; overflow: hidden; opacity: 0; visibility: hidden; transform: translate(-50%, -50%) scale(0.95); transition: opacity 0.3s ease, transform 0.3s ease; display: flex; flex-direction: column; }
        .panel.show { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); }
        .panel-header { display: flex; justify-content: space-between; align-items: center; padding: 15px 20px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .panel-header h3 { margin: 0; color: var(--text-primary); font-size: 1.6rem; }
        .panel-controls { display: flex; gap: 10px; }
        .panel-btn { background: none; color: var(--text-secondary); cursor: pointer; border: none; font-size: 1.2rem; padding: 5px; }
        .panel-content { padding: 20px 30px; overflow-y: auto; flex-grow: 1; }
        .collapsible { margin-bottom: 15px; border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; }
        .collapsible-header { padding: 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-weight: 600; background-color: var(--bg-tertiary); }
        .collapsible-header .fas { transition: transform 0.3s ease; }
        .collapsible-header.open .fas { transform: rotate(180deg); }
        .collapsible-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out, padding 0.4s ease; padding: 0 15px; background-color: var(--bg-secondary); }
        .collapsible-content.open { max-height: 4000px; padding: 15px; border-top: 1px solid var(--border-color); }
        .notification { position: fixed; bottom: 25px; left: 25px; transform: translateX(-150%); background-color: var(--bg-tertiary); color: var(--text-primary); padding: 14px 25px; border-radius: 8px; z-index: 1003; border: 1px solid var(--border-color); opacity: 0; visibility: hidden; transition: all 0.4s ease; }
        .notification.show { opacity: 1; transform: translateX(0); visibility: visible; }
        .tabs { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 25px; overflow-x: auto; }
        .tab-link { padding: 10px 15px; cursor: pointer; color: var(--text-secondary); border-bottom: 2px solid transparent; white-space: nowrap; font-size: 0.9rem; }
        .tab-link.active { color: var(--text-primary); font-weight: 600; background-color: var(--bg-tertiary); border-color: var(--accent-blue); border-top-left-radius: 6px; border-top-right-radius: 6px; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        #chartPanel { width: 90vw; max-width: 1200px; height: 80vh; padding: 0; }
        #chartContainer { width: 100%; flex-grow: 1; }
        .analysis-section { background-color: var(--bg-tertiary); padding: 20px; border-radius: 8px; margin-bottom: 15px; border: 1px solid var(--border-color); }
        .analysis-section h4 { color: #64b5f6; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-top: 0; font-size: 1.5rem; }
        .analysis-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px 20px; margin-bottom: 15px; }
        .analysis-item { display: flex; justify-content: space-between; background-color: rgba(255,255,255,0.03); padding: 8px 12px; border-radius: 6px; }
        .analysis-item .label { color: var(--text-secondary); }
        .analysis-item .value { font-weight: 600; }
        .analysis-summary { line-height: 1.6; margin-bottom: 10px; }
        .analysis-recommendation { font-weight: bold; font-size: 1.1rem; }
        .recommendation-al, .recommendation-guclu-al { font-weight: bold; color: var(--strong-buy); }
        .recommendation-sat, .recommendation-guclu-sat { font-weight: bold; color: var(--strong-sell); }
        .recommendation-tut { font-weight: bold; color: var(--accent-yellow); }
        .filters-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; }
        .filter-item { display: flex; align-items: center; background-color: var(--bg-tertiary); padding: 10px; border-radius: 6px; }
        .filter-item input { margin-right: 10px; accent-color: var(--accent-blue); }
        .analysis-actions { display: flex; justify-content: flex-start; align-items: center; margin-top: 20px; flex-wrap: wrap; gap: 15px; }
        .analysis-actions button { background-color: var(--accent-blue); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 1rem; display: flex; align-items: center; gap: 8px;}
        .global-analysis-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; gap: 15px;}
        .global-analysis-header h3 { margin: 0; color: var(--text-primary); font-size: 1.5rem; font-weight: 600; flex-basis: 100%; text-align: center; margin-bottom: 15px; }
        .global-analysis-controls { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .interval-filters { display: flex; gap: 10px; justify-content: center; flex-grow: 1; }
        .interval-filters button { background-color: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-color); padding: 8px 16px; border-radius: 20px; cursor: pointer; }
        .interval-filters button.active { background-color: var(--accent-blue); color: white; border-color: var(--accent-blue); }
        .ai-btn { background: linear-gradient(45deg, #4285F4, #9B72CB); color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; display: flex; align-items: center; gap: 8px;}
        .indicator-cards-container { display: grid; grid-template-columns: 1fr; gap: 20px; margin-top: 20px; }
        .indicator-card { background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-secondary)); border-radius: 12px; border: 1px solid var(--border-color); padding: 20px; transition: transform 0.3s ease, box-shadow 0.3s ease; }
        .indicator-card:hover { transform: translateY(-5px); box-shadow: 0 10px 20px rgba(0,0,0,0.3); }
        .indicator-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .indicator-card-header h4 { margin: 0; font-size: 1.5rem; color: #64b5f6; }
        .recommendation-badge { padding: 5px 12px; border-radius: 15px; font-weight: bold; color: white; font-size: 0.9rem; }
        .indicator-details-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px; margin-bottom: 15px; }
        .indicator-item { display: flex; justify-content: space-between; align-items: center; background-color: rgba(255,255,255,0.03); padding: 8px 12px; border-radius: 6px; }
        .indicator-item .label { font-size: 0.9rem; color: var(--text-secondary); }
        .indicator-item .value { font-size: 1rem; font-weight: 600; }
        .indicator-item .value.value-positive { color: var(--value-positive); }
        .indicator-item .value.value-negative { color: var(--value-negative); }
        .card-footer { margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; }
        .card-footer .summary { flex-grow: 1; font-size: 0.9rem; line-height: 1.5; color: var(--text-primary); }
        .dictionary-item { margin-bottom: 20px; }
        .dictionary-item h5 { color: #64b5f6; margin: 0 0 8px 0; font-size: 1.1rem; }
        .dictionary-item p { margin: 0 0 10px 0; line-height: 1.6; color: var(--text-secondary); }
        .dictionary-item .example { background-color: var(--bg-tertiary); padding: 10px; border-radius: 6px; font-style: italic; color: var(--text-primary); }
        .settings-section { margin-bottom: 25px; }
        .settings-section h4 { margin: 0 0 15px 0; color: var(--text-primary); font-size: 1.1rem; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
        .setting-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .setting-item label { font-weight: 500; color: var(--text-secondary); }
        .setting-item input, .setting-item select { background-color: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; padding: 8px 12px; }
        .color-input-wrapper { display: flex; align-items: center; gap: 10px; }
        .color-preview { width: 24px; height: 24px; border-radius: 4px; border: 1px solid var(--border-color); }
        #saveSettingsBtn { width: 100%; padding: 14px; font-size: 1.1rem; background-color: var(--accent-blue); border: none; border-radius: 8px; cursor: pointer; margin-top: 10px; }
        .pivot-filters { display: flex; gap: 10px; margin-bottom: 25px; flex-wrap: wrap; }
        .pivot-filters button { background-color: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-color); padding: 8px 16px; border-radius: 20px; cursor: pointer; }
        .pivot-filters button.active { background-color: var(--accent-blue); color: white; border-color: var(--accent-blue); }
        .pivot-container { display: flex; flex-direction: column; gap: 15px; }
        .pivot-bar-card { background-color: var(--bg-tertiary); padding: 20px; border-radius: 8px; border: 1px solid var(--border-color); }
        .pivot-bar-header { margin: 0 0 20px 0; color: #64b5f6; font-size: 1.2rem; font-weight: 600; }
        .pivot-bar-container { position: relative; height: 50px; display: flex; align-items: center; }
        .pivot-bar { height: 10px; width: 100%; border-radius: 5px; background: linear-gradient(to right, var(--accent-red), var(--accent-yellow), var(--accent-green)); position: relative; }
        .pivot-marker { position: absolute; top: -5px; height: 20px; width: 2px; background-color: rgba(255, 255, 255, 0.6); transform: translateX(-50%); }
        .pivot-values { display: flex; justify-content: space-between; margin-top: 10px; font-size: 0.8rem; color: var(--text-secondary); flex-wrap: wrap; }
        .current-price-indicator { position: absolute; top: 50%; transform: translate(-50%, -50%); width: 16px; height: 16px; background-color: var(--accent-blue); border: 2px solid white; border-radius: 50%; z-index: 3; transition: left 0.5s ease-out; }
        .current-price-indicator::before { content: attr(data-price); position: absolute; top: -25px; left: 50%; transform: translateX(-50%); background-color: var(--bg-primary); color: white; padding: 2px 6px; border-radius: 5px; font-size: 0.8rem; font-weight: bold; z-index: 2; white-space: nowrap; border: 1px solid var(--border-color); }
        .pivot-dictionary { margin-top: 20px; background-color: var(--bg-tertiary); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); font-size: 0.9rem;}
        .pivot-dictionary p { margin: 5px 0; }
        .pivot-dictionary span { font-weight: bold; color: var(--text-primary); }
        @media (max-width: 768px) {
            th, td { padding: 12px 6px; font-size: 0.85rem; }
            .app-header .header-left h1 { font-size: 1.4rem; }
            .add-asset-bar { flex-direction: column; }
            .add-asset-bar button { width: 100%; }
            .pivot-values { font-size: 0.7rem; }
            .analysis-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <div id="login-page" class="page">
        <div class="login-container">
            <h1><i class="fas fa-chart-line"></i> Fiyat Takipçisi</h1>
            <p data-lang="login_prompt">Devam etmek için giriş yapın veya yeni hesap oluşturun.</p>
            <div class="input-group"><label for="email" data-lang="email">E-posta</label><input type="email" id="email" autocomplete="email"></div>
            <div class="input-group"><label for="password" data-lang="password">Şifre</label><input type="password" id="password" autocomplete="current-password"></div>
            <div id="error-message"></div>
            <div class="button-group">
                <button id="loginBtn" data-lang="login">Giriş Yap</button>
                <button id="signupBtn" data-lang="signup" style="background-color: #373c4a;">Kayıt Ol</button>
            </div>
        </div>
    </div>

    <div id="tracker-page" class="page" style="display: none;">
        <div class="tracker-container">
            <header class="app-header">
                 <div class="header-left"><h1><i class="fas fa-chart-line"></i> <span data-lang="app_title">Fiyat Takipçisi</span></h1></div>
                <div class="header-right">
                    <div class="main-actions">
                        <button id="refreshBtn" title="Yenile"><i class="fas fa-sync-alt"></i></button>
                        <button id="settingsBtn" title="Ayarlar"><i class="fas fa-cog"></i></button>
                    </div>
                    <div class="user-menu">
                        <button id="userMenuBtn"><i class="fas fa-user-circle"></i> <span id="userEmail"></span></button>
                        <div class="dropdown-content">
                            <a href="#" id="logoutBtn"><i class="fas fa-sign-out-alt"></i> <span data-lang="logout">Çıkış Yap</span></a>
                        </div>
                    </div>
                </div>
            </header>

            <div class="tabs">
                <div class="tab-link active" data-tab="crypto">Kripto</div>
                <div class="tab-link" data-tab="crypto-ai">Kripto AI</div>
                <div class="tab-link" data-tab="crypto-pivot">AI Pivot</div>
            </div>

            <div id="crypto-content" class="tab-content active">
                 <div class="add-asset-bar">
                    <input type="text" id="newCoinInput" placeholder="BTC, ETH, SOL...">
                    <button id="addCoinBtn"><i class="fas fa-plus"></i> <span data-lang="add">Ekle</span></button>
                </div>
                <div class="table-controls">
                    <button id="toggleSortBtn"><i class="fas fa-sort"></i> Sırala</button>
                </div>
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th class="drag-handle-col hidden"><i class="fas fa-grip-lines"></i></th>
                                <th class="sortable" data-sort-key="pair"><span data-lang="coin">Coin</span><span class="sort-indicator"></span></th>
                                <th class="sortable" data-sort-key="latestPrice"><span data-lang="price">Fiyat</span><span class="sort-indicator"></span></th>
                                <th id="col1_header_crypto" class="sortable" data-sort-key="col1"></th>
                                <th id="col2_header_crypto" class="sortable" data-sort-key="col2"></th>
                                <th id="col3_header_crypto" class="sortable" data-sort-key="col3"></th>
                                <th data-lang="delete">Sil</th>
                            </tr>
                        </thead>
                        <tbody id="cryptoPriceTable"></tbody>
                    </table>
                </div>
            </div>

            <div id="crypto-ai-content" class="tab-content">
                <div class="collapsible">
                    <div class="collapsible-header open"><span>Analiz Filtreleri</span><i class="fas fa-chevron-down"></i></div>
                    <div class="collapsible-content open">
                        <div class="interval-filters" id="cryptoIntervalFilters" style="margin-bottom: 20px;">
                             <button class="interval-btn" data-interval="1h">1 Saat</button>
                             <button class="interval-btn active" data-interval="4h">4 Saat</button>
                             <button class="interval-btn" data-interval="1d">1 Gün</button>
                        </div>
                        <div id="crypto-indicator-filters-grid" class="filters-grid"></div>
                        <div class="analysis-actions">
                            <button id="updateCryptoAnalysisBtn"><i class="fas fa-check"></i> Analizi Güncelle</button>
                        </div>
                    </div>
                </div>
                <div class="global-analysis-header">
                    <h3>Otomatik Analiz Sonuçları</h3>
                    <div class="global-analysis-controls">
                         <div class="pivot-filters" id="cryptoRecommendationFilters">
                            <button class="active" data-filter="all">Tümü</button>
                            <button data-filter="buy">Al</button>
                            <button data-filter="sell">Sat</button>
                            <button data-filter="hold">Tut</button>
                        </div>
                        <button id="analyzeAllCryptoBtn" class="ai-btn" title="Tüm listeyi Gemini ile yorumla"><i class="fas fa-magic-sparkles"></i> Toplu Yorumla</button>
                    </div>
                </div>
                <div id="crypto-indicator-cards-container" class="indicator-cards-container"></div>
                 <div class="collapsible" style="margin-top: 30px;">
                    <div class="collapsible-header">
                        <span>İndikatör Sözlüğü</span>
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="collapsible-content" id="dictionaryContent"></div>
                </div>
            </div>

            <div id="crypto-pivot-content" class="tab-content">
                <div class="pivot-filters" id="cryptoPivotFilters">
                    <button class="active" data-filter="all">Tümü</button>
                    <button data-filter="above">Pivot Üstü</button>
                    <button data-filter="below">Pivot Altı</button>
                </div>
                <div id="crypto-pivot-container" class="pivot-container"></div>
                 <div id="pivot-dictionary-container"></div>
            </div>

            <div class="update-time"><i class="far fa-clock"></i>&nbsp;<span data-lang="last_update">Son güncelleme</span>: <span id="updateTime"></span></div>
        </div>
    </div>

    <div id="settingsPanel" class="panel">
        <div class="panel-header">
            <h3 data-lang="settings">Ayarlar</h3>
            <div class="panel-controls"><button class="panel-btn close-btn"><i class="fas fa-times"></i></button></div>
        </div>
        <div class="panel-content">
            <div class="settings-section">
                <h4 data-lang="general_settings">Genel Ayarlar</h4>
                <div class="setting-item"><label data-lang="language">Dil</label><select id="langSelect"><option value="tr">Türkçe</option><option value="en">English</option></select></div>
                <div class="setting-item"><label data-lang="auto_refresh">Otomatik Yenileme</label><input type="checkbox" id="autoRefreshToggle"></div>
                <div class="setting-item"><label data-lang="refresh_interval">Yenileme Aralığı (sn)</label><input type="number" id="refreshInterval" min="10" step="10"></div>
            </div>
            <div class="settings-section">
                <h4 data-lang="column_settings">Kolon Ayarları</h4>
                <div class="setting-item"><label>Kolon 1 Adı</label><input type="text" id="col1_name_input"></div>
                <div class="setting-item"><label>Gün Sayısı</label><input type="number" id="col1_days_input" min="1"></div>
                <div class="setting-item"><label>Pozitif Eşik (%)</label><input type="number" id="col1_threshold_input" min="0"></div><hr>
                <div class="setting-item"><label>Kolon 2 Adı</label><input type="text" id="col2_name_input"></div>
                <div class="setting-item"><label>Gün Sayısı</label><input type="number" id="col2_days_input" min="1"></div>
                <div class="setting-item"><label>Pozitif Eşik (%)</label><input type="number" id="col2_threshold_input" min="0"></div><hr>
                <div class="setting-item"><label>Kolon 3 Adı</label><input type="text" id="col3_name_input"></div>
                <div class="setting-item"><label>Gün Sayısı</label><input type="number" id="col3_days_input" min="1"></div>
                <div class="setting-item"><label>Pozitif Eşik (%)</label><input type="number" id="col3_threshold_input" min="0"></div>
            </div>
            <div class="settings-section">
                <h4 data-lang="color_settings">Renk Ayarları</h4>
                <div class="setting-item"><label data-lang="high_positive_color">Yüksek Pozitif Renk</label><div class="color-input-wrapper"><input type="color" id="high_color_input"><span class="color-preview" id="high_color_preview"></span></div></div>
                <div class="setting-item"><label data-lang="low_positive_color">Düşük Pozitif Renk</label><div class="color-input-wrapper"><input type="color" id="low_color_input"><span class="color-preview" id="low_color_preview"></span></div></div>
            </div>
            <button id="saveSettingsBtn" data-lang="save_settings">Ayarları Kaydet</button>
        </div>
    </div>

    <div id="detailPanel" class="panel">
         <div class="panel-header">
            <h3 id="detailPanelTitle"></h3>
             <div class="panel-controls"><button class="panel-btn close-btn"><i class="fas fa-times"></i></button></div>
        </div>
        <div class="panel-content" id="detailPanelContent"></div>
    </div>

    <div id="chartPanel" class="panel">
        <div class="panel-header">
            <h3 id="chartPanelTitle"></h3>
            <div class="panel-controls"><button class="panel-btn close-btn" title="Kapat"><i class="fas fa-times"></i></button></div>
        </div>
        <div id="chartContainer"></div>
    </div>

    <div id="analysisPanel" class="panel">
        <div class="panel-header">
            <h3>AI Analizi</h3>
            <div class="panel-controls"><button class="panel-btn close-btn" title="Kapat"><i class="fas fa-times"></i></button></div>
        </div>
        <div id="analysisContent" class="panel-content"></div>
    </div>
    <div id="modalOverlay" class="modal-overlay"></div>
    <div class="notification" id="notification"></div>

<script>
    // #############################################################################
    // # DİKKAT! BURAYA KENDİ FIREBASE PROJE BİLGİLERİNİZİ GİRMENİZ GEREKİYOR! #
    // #############################################################################
    const firebaseConfig = {
        apiKey: "AIzaSyA3flTu3Jz9E1D1U_DympYE7B4I4FDxj88",
        authDomain: "fiyattakipv3.firebaseapp.com",
        projectId: "fiyattakipv3",
        storageBucket: "fiyattakipv3.firebasestorage.app",
        messagingSenderId: "440839843277",
        appId: "1:440839843277:web:2c9c15e4a103e8b2f2e884"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const functions = firebase.functions();

    // --- GLOBAL STATE ---
    let currentUserRole = null, coinLimit = 10, settings = {}, autoRefreshTimer = null, pageInitialized = false;
    let allCryptoData = [];
    let currentSort = { key: null, order: 'default' }; // 'default', 'asc', 'desc'
    let cryptoPairs = [];
    let userDocRef = null;
    let sortableInstance = null;
    let currentRecommendationFilter = 'all';
    const loginPage = document.getElementById('login-page'), trackerPage = document.getElementById('tracker-page'), notification = document.getElementById("notification"), modalOverlay = document.getElementById('modalOverlay');

    const AVAILABLE_INDICATORS = {
        ema: "EMA", sma: "SMA", rsi: "RSI", macd: "MACD",
        bollinger: "Bollinger Bands", stochRsi: "Stochastic RSI",
        volume: "Hacim (24s)", atr: "ATR", ichimoku: "Ichimoku Cloud", fibonacci: "Fibonacci"
    };

    const translations = { 
        tr: { 
            login_prompt: "Devam etmek için giriş yapın veya yeni hesap oluşturun.", email: "E-posta", password: "Şifre", login: "Giriş Yap", signup: "Kayıt Ol", logout: "Çıkış Yap", app_title: "Fiyat Takipçisi", add: "Ekle", refresh: "Yenile", settings: "Ayarlar", coin: "Coin", price: "Fiyat", delete: "Sil", last_update: "Son güncelleme", color_rules: "Renk Kuralları", general_settings: "Genel Ayarlar", language: "Dil", auto_refresh: "Otomatik Yenileme", refresh_interval: "Yenileme Aralığı (sn)", column_settings: "Kolon Ayarları", positive_threshold: "Pozitif Eşik (%)", color_settings: "Renk Ayarları", high_positive_color: "Yüksek Pozitif Renk", low_positive_color: "Düşük Pozitif Renk", save_settings: "Ayarları Kaydet", saved: "Kaydedildi!", settings_saved: "Ayarlar başarıyla kaydedildi.", analysis_updated: "Analiz başarıyla güncellendi.", limit_exceeded: "Limit aşıldı!", 
            role_info: (role, limit, type) => `Rolünüz (${role}) en fazla ${limit} ${type} eklemeye izin veriyor.`, 
            invalid_asset: (asset) => `Geçersiz varlık: ${asset}`, 
            already_in_list: (asset) => `${asset} zaten listede.`, 
            lowest_price_detail: (period, lowestPrice, lowestDate, currentPrice, pctChange) => `
                <div style="line-height: 1.8; font-size: 0.95rem;">
                    <p style="border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 10px;"><strong>${period} periyodundaki analiz:</strong></p>
                    <p>Bu dönemdeki en düşük fiyat: <strong style="color: var(--accent-yellow);">${lowestPrice}</strong><br><small>(Tarih: ${lowestDate})</small></p>
                    <p>Mevcut Fiyat: <strong style="color: var(--accent-blue);">${currentPrice}</strong></p>
                    <hr style="border-color: var(--border-color); margin: 15px 0;">
                    <p>Hesaplanan Değişim: <strong style="font-size: 1.2rem; color: ${pctChange > 0 ? 'var(--accent-green)' : 'var(--accent-red)'};">${pctChange}%</strong></p>
                </div>
            `,
            no_data: "Veri yok" 
        }, 
        en: {} 
    };

    function translatePage(lang) { document.querySelectorAll('[data-lang]').forEach(el => { const key = el.getAttribute('data-lang'); if (translations[lang]?.[key] && typeof translations[lang][key] === 'string') el.textContent = translations[lang][key]; }); }
    function showPage(pageId) { loginPage.style.display = (pageId === 'login-page') ? 'flex' : 'none'; trackerPage.style.display = (pageId === 'tracker-page') ? 'flex' : 'none'; }
    function showPanel(panelId) { document.getElementById(panelId).classList.add('show'); modalOverlay.classList.add('show'); document.body.classList.add('modal-open'); }
    function closeAllPanels() { document.querySelectorAll('.panel.show').forEach(p => p.classList.remove('show')); modalOverlay.classList.remove('show'); document.body.classList.remove('modal-open'); }
    function showNotification(message, isSuccess = true) { notification.textContent = message; notification.style.backgroundColor = isSuccess ? 'var(--accent-green)' : 'var(--accent-red)'; notification.classList.add('show'); setTimeout(() => notification.classList.remove('show'), 3000); }

    function showLoading(button) { button.dataset.originalHtml = button.innerHTML; button.innerHTML = '<div class="loading"></div>'; button.disabled = true; }
    function hideLoading(button) { if (button.dataset.originalHtml) { button.innerHTML = button.dataset.originalHtml; } button.disabled = false; }


    document.getElementById('loginBtn').addEventListener('click', () => auth.signInWithEmailAndPassword(document.getElementById("email").value, document.getElementById("password").value).catch(err => document.getElementById("error-message").textContent = err.message));
    document.getElementById('signupBtn').addEventListener('click', () => auth.createUserWithEmailAndPassword(document.getElementById("email").value, document.getElementById("password").value).catch(err => document.getElementById("error-message").textContent = err.message));
    
    auth.onAuthStateChanged(async user => {
        if (user) {
            userDocRef = db.collection('users').doc(user.uid);
            try {
                const doc = await userDocRef.get();
                let userData = doc.data();
                if (!doc.exists) {
                     userData = { email: user.email, role: 'new_user', coins: ["BTCUSDT", "ETHUSDT", "SOLUSDT"], settings: getDefaultSettings() };
                    await userDocRef.set(userData);
                }
                setRoleAndLimits(userData.role);
                if (!pageInitialized) {
                    await initializeTrackerPage(userData);
                }
                showPage('tracker-page');
            } catch (err) {
                console.error("Auth/Firestore Error:", err);
                if (err.code === 'permission-denied') { document.getElementById("error-message").textContent = "Firestore yetki hatası. Lütfen veritabanı kurallarınızı kontrol edin."; }
                auth.signOut();
            }
        } else {
            showPage('login-page');
            pageInitialized = false;
            userDocRef = null;
            if(autoRefreshTimer) clearInterval(autoRefreshTimer);
        }
    });

    function setRoleAndLimits(role) {
        currentUserRole = role;
        const limits = { admin: {coin: Infinity}, qualified: {coin: 20}, new_user: {coin: 10} };
        coinLimit = limits[currentUserRole]?.coin ?? 10;
        document.getElementById('userEmail').textContent = auth.currentUser.email;
        updateAdminUI();
    }

    function updateAdminUI() {
        const isAdmin = currentUserRole === 'admin';
        document.getElementById('analyzeAllCryptoBtn').style.display = isAdmin ? 'flex' : 'none';
    }
    
    async function initializeTrackerPage(userData) {
        pageInitialized = true;
        cryptoPairs = userData.coins || ["BTCUSDT", "ETHUSDT", "SOLUSDT"];

        const saveCryptoPairsToFirestore = () => { if (userDocRef) { userDocRef.update({ coins: cryptoPairs }).catch(error => console.error("Firebase kaydetme hatası (Kripto):", error)); } };

        const formatPrice = (price) => {
            const num = parseFloat(price);
            if (isNaN(num)) return 'N/A';
            let formattedPrice;
            if (num < 0.001) formattedPrice = num.toFixed(8);
            else if (num < 1) formattedPrice = num.toFixed(6);
            else if (num < 10) formattedPrice = num.toFixed(4);
            else formattedPrice = num.toFixed(2);
            return parseFloat(formattedPrice).toString();
        };

        const formatVolume = (volume) => { const num = parseFloat(volume); if (isNaN(num)) return 'N/A'; if (num >= 1_000_000_000) return `${(num / 1_000_000_000).toFixed(2)}B`; if (num >= 1_000_000) return `${(num / 1_000_000).toFixed(2)}M`; if (num >= 1_000) return `${(num / 1_000).toFixed(2)}K`; return num.toFixed(0); };

        function getDefaultSettings() {
            return {
                lang: 'tr', autoRefresh: false, refreshInterval: 300,
                columns: { 1: { name: '1G', days: 1, threshold: 2 }, 2: { name: '7G', days: 7, threshold: 5 }, 3: { name: '30G', days: 30, threshold: 10 } },
                colors: { high: '#26a69a', low: '#f59e0b' },
                cryptoPivotFilter: 'all',
                cryptoAnalysisInterval: '4h',
                cryptoAnalysisIndicators: { ema: true, rsi: true, macd: true, bollinger: true, volume: false, sma: false, stochRsi: false, atr: false, ichimoku: false, fibonacci: false }
            };
        }

        function loadSettings(userData) {
            const defaultSettings = getDefaultSettings();
            settings = { ...defaultSettings, ...userData.settings };
            settings.columns = { ...defaultSettings.columns, ...(userData.settings?.columns || {}) };
            settings.colors = { ...defaultSettings.colors, ...(userData.settings?.colors || {}) };
            settings.cryptoAnalysisIndicators = { ...defaultSettings.cryptoAnalysisIndicators, ...(userData.settings?.cryptoAnalysisIndicators || {}) };
            applySettings();
        }

        function saveSettings() {
            const btn = document.getElementById('saveSettingsBtn');
            showLoading(btn);

            let interval = parseInt(document.getElementById('refreshInterval').value);
            const minInterval = { admin: 10, qualified: 120, new_user: 300 }[currentUserRole] || 300;
            if (interval < minInterval) interval = minInterval;
            settings.lang = document.getElementById('langSelect').value;
            settings.autoRefresh = document.getElementById('autoRefreshToggle').checked;
            settings.refreshInterval = interval;
            settings.columns = { 1: { name: document.getElementById('col1_name_input').value, days: parseInt(document.getElementById('col1_days_input').value), threshold: parseFloat(document.getElementById('col1_threshold_input').value) }, 2: { name: document.getElementById('col2_name_input').value, days: parseInt(document.getElementById('col2_days_input').value), threshold: parseFloat(document.getElementById('col2_threshold_input').value) }, 3: { name: document.getElementById('col3_name_input').value, days: parseInt(document.getElementById('col3_days_input').value), threshold: parseFloat(document.getElementById('col3_threshold_input').value) } };
            settings.colors = { high: document.getElementById('high_color_input').value, low: document.getElementById('low_color_input').value };

            if (userDocRef) {
                userDocRef.update({ settings: settings }).then(() => {
                    applySettings();
                    closeAllPanels();
                    showNotification(translations[settings.lang].settings_saved, true);
                    fetchAllDataAndRender();
                }).catch(error => {
                    console.error("Firebase ayar kaydetme hatası:", error);
                    showNotification("Ayarları kaydederken hata oluştu.", false);
                }).finally(() => {
                    hideLoading(btn);
                });
            }
        }

        function updateAnalysisSettings(type) {
            const btn = document.getElementById('updateCryptoAnalysisBtn');
            showLoading(btn);
            
            settings.cryptoAnalysisInterval = document.querySelector('#cryptoIntervalFilters button.active').dataset.interval;

            settings[`${type}AnalysisIndicators`] = {};
            document.querySelectorAll(`#${type}-indicator-filters-grid input[type="checkbox"]`).forEach(checkbox => {
                settings[`${type}AnalysisIndicators`][checkbox.dataset.indicator] = checkbox.checked;
            });
            if (userDocRef) {
                userDocRef.update({ 
                    'settings.cryptoAnalysisIndicators': settings.cryptoAnalysisIndicators,
                    'settings.cryptoAnalysisInterval': settings.cryptoAnalysisInterval
                }).then(() => {
                    showNotification(translations[settings.lang].analysis_updated, true);
                    fetchAllDataAndRender(); 
                }).catch(error => {
                    console.error("Firebase analiz ayarı kaydetme hatası:", error);
                    showNotification("Analiz ayarları güncellenirken bir hata oluştu.", false);
                }).finally(() => {
                    hideLoading(btn);
                });
            }
        }


        function applySettings() {
            document.getElementById('langSelect').value = settings.lang;
            document.getElementById('autoRefreshToggle').checked = settings.autoRefresh;
            document.getElementById('refreshInterval').value = settings.refreshInterval;
            document.getElementById('refreshInterval').min = { admin: 10, qualified: 120, new_user: 300 }[currentUserRole] || 300;

            for (let i = 1; i <= 3; i++) {
                document.getElementById(`col${i}_name_input`).value = settings.columns[i].name;
                document.getElementById(`col${i}_days_input`).value = settings.columns[i].days;
                document.getElementById(`col${i}_threshold_input`).value = settings.columns[i].threshold;
                document.getElementById(`col${i}_header_crypto`).innerHTML = `${settings.columns[i].name}<span class="sort-indicator"></span>`;
            }
            document.getElementById('high_color_input').value = settings.colors.high;
            document.getElementById('low_color_input').value = settings.colors.low;
            document.getElementById('high_color_preview').style.backgroundColor = settings.colors.high;
            document.getElementById('low_color_preview').style.backgroundColor = settings.colors.low;

            document.querySelectorAll(`#cryptoPivotFilters button.active, #cryptoIntervalFilters button.active`).forEach(b => b.classList.remove('active'));
            document.querySelector(`#cryptoPivotFilters button[data-filter="${settings.cryptoPivotFilter}"]`)?.classList.add('active');
            document.querySelector(`#cryptoIntervalFilters button[data-interval="${settings.cryptoAnalysisInterval}"]`)?.classList.add('active');

            Object.keys(AVAILABLE_INDICATORS).forEach(key => {
                const checkbox = document.querySelector(`#crypto-indicator-filters-grid input[data-indicator="${key}"]`);
                if (checkbox) checkbox.checked = !!settings.cryptoAnalysisIndicators[key];
            });
            translatePage(settings.lang);
            toggleAutoRefresh();
        }

        function toggleAutoRefresh() { if(autoRefreshTimer) clearInterval(autoRefreshTimer); if(settings.autoRefresh) autoRefreshTimer = setInterval(fetchAllDataAndRender, settings.refreshInterval * 1000); }

        const calculateSMA = (data, period) => { if (data.length < period) return null; return data.slice(-period).reduce((s, v) => s + v, 0) / period; };
        const calculateEMA = (data, period) => { if (data.length < period) return null; const k = 2 / (period + 1); let ema = calculateSMA(data.slice(0, period), period); for (let i = period; i < data.length; i++) { ema = (data[i] * k) + (ema * (1 - k)); } return ema; };
        const calculateStdDev = (data, period) => { let mean = data.reduce((s, v) => s + v, 0) / period; return Math.sqrt(data.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / period); };
        const calculateBollingerBands = (data, period = 20, stdDev = 2) => { if (data.length < period) return null; const middle = calculateEMA(data, period); const deviation = calculateStdDev(data.slice(-period), period); return { upper: middle + (deviation * stdDev), middle: middle, lower: middle - (deviation * stdDev) }; };
        const calculateRSI = (data, period = 14) => { if (data.length <= period) return null; let gains = 0, losses = 0; for (let i = 1; i < data.length; i++) { const diff = data[i] - data[i - 1]; if (i <= period) { if (diff >= 0) { gains += diff; } else { losses -= diff; } } } let avgGain = gains / period, avgLoss = losses / period; for (let i = period + 1; i < data.length; i++) { const diff = data[i] - data[i - 1]; if (diff >= 0) { avgGain = (avgGain * (period - 1) + diff) / period; avgLoss = (avgLoss * (period - 1)) / period; } else { avgLoss = (avgLoss * (period - 1) - diff) / period; avgGain = (avgGain * (period - 1)) / period; } } if (avgLoss === 0) return 100; const rs = avgGain / avgLoss; return 100 - (100 / (1 + rs)); };
        const calculateStochasticRSI = (data, period = 14) => { if (data.length < period * 2) return null; const rsiValues = []; for(let i = period; i < data.length; i++) { const rsi = calculateRSI(data.slice(0, i + 1), period); if (rsi !== null) rsiValues.push(rsi); } if (rsiValues.length < period) return null; const currentRSI = rsiValues[rsiValues.length - 1]; const rsiSlice = rsiValues.slice(-period); const lowestRSI = Math.min(...rsiSlice); const highestRSI = Math.max(...rsiSlice); if (highestRSI === lowestRSI) return {k: 100}; return { k: ((currentRSI - lowestRSI) / (highestRSI - lowestRSI)) * 100 }; };
        const calculateATR = (klines, period = 14) => { if (klines.length < period + 1) return null; let trs = []; for (let i = 1; i < klines.length; i++) { const high = parseFloat(klines[i][2]), low = parseFloat(klines[i][3]), prevClose = parseFloat(klines[i-1][4]); trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose))); } if (trs.length < period) return null; return trs.slice(-period).reduce((s, v) => s + v, 0) / period; };
        const calculateMACD = (data, fast = 12, slow = 26, signal = 9) => { if (data.length < slow) return null; const macdLineData = []; for (let i = slow - 1; i < data.length; i++) { const fastEma = calculateEMA(data.slice(0, i + 1), fast); const slowEma = calculateEMA(data.slice(0, i + 1), slow); if (fastEma !== null && slowEma !== null) macdLineData.push(fastEma - slowEma); } if (macdLineData.length < signal) return null; const signalLine = calculateEMA(macdLineData, signal); const macdLine = macdLineData[macdLineData.length - 1]; return { macd: macdLine, signal: signalLine, histogram: macdLine - signalLine }; };
        const calculateIchimokuCloud = (klines) => { if (klines.length < 52) return null; const slice = klines.slice(-52); const high9 = Math.max(...slice.slice(-9).map(k => parseFloat(k[2]))); const low9 = Math.min(...slice.slice(-9).map(k => parseFloat(k[3]))); const tenkanSen = (high9 + low9) / 2; const high26 = Math.max(...slice.slice(-26).map(k => parseFloat(k[2]))); const low26 = Math.min(...slice.slice(-26).map(k => parseFloat(k[3]))); const kijunSen = (high26 + low26) / 2; const senkouSpanA = (tenkanSen + kijunSen) / 2; const high52 = Math.max(...slice.map(k => parseFloat(k[2]))); const low52 = Math.min(...slice.map(k => parseFloat(k[3]))); const senkouSpanB = (high52 + low52) / 2; return { tenkanSen, kijunSen, senkouSpanA, senkouSpanB }; };
        const calculateFibonacciRetracement = (klines, period = 100) => { if (klines.length < period) return null; const slice = klines.slice(-period); const high = Math.max(...slice.map(k => parseFloat(k[2]))); const low = Math.min(...slice.map(k => parseFloat(k[3]))); const diff = high - low; return { level_236: high - diff * 0.236, level_382: high - diff * 0.382, level_500: high - diff * 0.5, level_618: high - diff * 0.618, }; };

        async function fetchCryptoData(pair) {
            try {
                const timeout = 5000;
                const [analysisKlinesResponse, dailyKlinesResponse, tickerResponse] = await Promise.all([
                    axios.get(`https://api.binance.com/api/v3/klines?symbol=${pair}&interval=${settings.cryptoAnalysisInterval}&limit=400`, { timeout }),
                    axios.get(`https://api.binance.com/api/v3/klines?symbol=${pair}&interval=1d&limit=1000`, { timeout }),
                    axios.get(`https://api.binance.com/api/v3/ticker/24hr?symbol=${pair}`, { timeout })
                ]);
                const analysisKlines = analysisKlinesResponse.data, dailyKlines = dailyKlinesResponse.data, tickerData = tickerResponse.data;
                if (!analysisKlines || analysisKlines.length < 52 || !dailyKlines || dailyKlines.length < 2) throw new Error("Yetersiz geçmiş veri.");

                const latestPrice = parseFloat(tickerData.lastPrice);
                const analysisClosePrices = analysisKlines.map(d => parseFloat(d[4]));
                const calculatePct = (col) => {
                    const days = settings.columns[col].days;
                    if (dailyKlines.length < days + 1) return { pct: 'N/A' };
                    const periodData = dailyKlines.slice(-(days + 1), -1);
                    let lowestPrice = Infinity, lowestDate = null;
                    periodData.forEach(d => { const low = parseFloat(d[3]); if (low < lowestPrice) { lowestPrice = low; lowestDate = new Date(d[0]); } });
                    if (lowestPrice === Infinity) return { pct: 'N/A' };
                    return { pct: ((latestPrice - lowestPrice) / lowestPrice * 100), lowestPrice, lowestDate: lowestDate.toLocaleDateString(settings.lang) };
                };
                const yesterday = dailyKlines[dailyKlines.length - 2];
                const high = parseFloat(yesterday[2]), low = parseFloat(yesterday[3]), close = parseFloat(yesterday[4]);
                const pivot = (high + low + close) / 3;

                return {
                    pair, latestPrice, error: false, type: 'crypto', currency: 'USDT',
                    col1: calculatePct(1), col2: calculatePct(2), col3: calculatePct(3),
                    sr: { r2: pivot + (high - low), r1: (2 * pivot) - low, pivot: pivot, s1: (2 * pivot) - high, s2: pivot - (high - low) },
                    indicators: { sma: calculateSMA(analysisClosePrices, 50), ema: calculateEMA(analysisClosePrices, 50), rsi: calculateRSI(analysisClosePrices, 14), macd: calculateMACD(analysisClosePrices), bollinger: calculateBollingerBands(analysisClosePrices), stochRsi: calculateStochasticRSI(analysisClosePrices, 14), volume: parseFloat(tickerData.quoteVolume), atr: calculateATR(analysisKlines, 14), ichimoku: calculateIchimokuCloud(analysisKlines), fibonacci: calculateFibonacciRetracement(analysisKlines) }
                };
            } catch (error) {
                console.error(`${pair} verisi çekilirken hata oluştu:`, error);
                return { pair, error: true, type: 'crypto' };
            }
        }

        async function fetchAllDataAndRender() {
            const refreshBtn = document.getElementById('refreshBtn');
            showLoading(refreshBtn);
            
            allCryptoData = [];
            renderLoadingSkeletons('crypto', cryptoPairs, document.getElementById('cryptoPriceTable'));
            allCryptoData = await Promise.all(cryptoPairs.map(fetchCryptoData));

            allCryptoData.forEach(asset => {
                if(!asset.error) {
                    const { recommendation, color, summary, category } = getRecommendation(asset, settings.cryptoAnalysisIndicators);
                    asset.recommendation = recommendation;
                    asset.recommendationColor = color;
                    asset.recommendationSummary = summary;
                    asset.recommendationCategory = category;
                }
            });

            sortAndRenderTable();
            renderIndicatorCards('crypto');
            renderSupportResistance('crypto', allCryptoData);
            hideLoading(refreshBtn);
            updateTime.textContent = new Date().toLocaleString(settings.lang);
        }

        function renderLoadingSkeletons(type, pairs, tableBody) {
            tableBody.innerHTML = '';
            pairs.forEach(pair => {
                const row = document.createElement("tr");
                row.dataset.pair = pair;
                row.innerHTML = `<td class="drag-handle-col hidden"><i class="fas fa-grip-lines drag-handle"></i></td><td class="asset-cell" data-pair="${pair}" data-type="${type}">${pair.replace("USDT", "")}</td><td colspan="5" style="text-align:center;"><div class="loading"></div></td>`;
                tableBody.appendChild(row);
            });
        }

        function sortAndRenderTable() {
            const { key, order } = currentSort;
            let sortedData = (order === 'default') ? [...allCryptoData] : [...allCryptoData].sort((a, b) => {
                let valA, valB;
                if (key.startsWith('col')) {
                    valA = a[key]?.pct;
                    valB = b[key]?.pct;
                } else {
                    valA = a[key];
                    valB = b[key];
                }

                if (a.error) return 1; if (b.error) return -1;
                if (valA === undefined || valA === null) return 1;
                if (valB === undefined || valB === null) return -1;

                if (typeof valA === 'string') {
                    return order === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                } else {
                    return order === 'asc' ? valA - valB : valB - valA;
                }
            });

            document.querySelectorAll('#crypto-content th.sortable').forEach(th => {
                th.classList.remove('asc', 'desc');
                if (th.dataset.sortKey === key && order !== 'default') {
                    th.classList.add(order);
                }
            });
            updateAllTableRows('crypto', sortedData);
        }

        function updateAllTableRows(type, data) {
            const tableBody = document.getElementById(`${type}PriceTable`);
            tableBody.innerHTML = '';
            const isSorting = !document.querySelector('.drag-handle-col.hidden');
            data.forEach(result => {
                const row = document.createElement("tr");
                row.dataset.pair = result.pair;
                const getCellStyle = (colData, threshold) => { const pct = colData?.pct; if (isNaN(pct)) return ''; if (pct < 0) return 'class="negative"'; if (pct >= threshold) return `class="positive-high" style="color: ${settings.colors.high};"`; return `class="positive-low" style="color: ${settings.colors.low};"`; };
                let rowHTML;
                if (result.error) {
                    rowHTML = `<td class="drag-handle-col ${isSorting ? '' : 'hidden'}"><i class="fas fa-grip-lines drag-handle"></i></td><td class="asset-cell">${result.pair.replace("USDT", "")}</td><td colspan="5" style="text-align:center; color: var(--accent-red);">Veri alınamadı</td>`;
                } else {
                    rowHTML = `
                        <td class="drag-handle-col ${isSorting ? '' : 'hidden'}"><i class="fas fa-grip-lines drag-handle"></i></td>
                        <td class="asset-cell" data-pair="${result.pair}" data-type="${type}">${result.pair.replace("USDT", "")}</td>
                        <td>${formatPrice(result.latestPrice)}</td>
                        <td ${getCellStyle(result.col1, settings.columns[1].threshold)} class="clickable-pct" data-col="1" data-pair="${result.pair}" data-type="${type}">${result.col1.pct?.toFixed(2)}%</td>
                        <td ${getCellStyle(result.col2, settings.columns[2].threshold)} class="clickable-pct" data-col="2" data-pair="${result.pair}" data-type="${type}">${result.col2.pct?.toFixed(2)}%</td>
                        <td ${getCellStyle(result.col3, settings.columns[3].threshold)} class="clickable-pct" data-col="3" data-pair="${result.pair}" data-type="${type}">${result.col3.pct?.toFixed(2)}%</td>
                    `;
                }
                rowHTML += `<td><button class="action-btn remove-btn" data-pair="${result.pair}" data-type="${type}"><i class="fas fa-times"></i></button></td>`;
                row.innerHTML = rowHTML;
                tableBody.appendChild(row);
            });
        }


        function renderSupportResistance(type, data) {
            const container = document.getElementById('crypto-pivot-container');
            container.innerHTML = '';
            document.getElementById('pivot-dictionary-container').innerHTML = `
                <div class="pivot-dictionary">
                    <p><span>P:</span> Pivot Noktası (Referans)</p>
                    <p><span>R1, R2:</span> Direnç Seviyeleri (Yükseliş Hedefleri)</p>
                    <p><span>S1, S2:</span> Destek Seviyeleri (Düşüş Durakları)</p>
                </div>`;

            const filter = settings[`${type}PivotFilter`];
            data.filter(asset => !asset.error && asset.sr).forEach(asset => {
                if ((filter === 'above' && asset.latestPrice < asset.sr.pivot) || (filter === 'below' && asset.latestPrice > asset.sr.pivot)) return;

                const { s2, s1, pivot, r1, r2 } = asset.sr;
                const min = s2, max = r2;
                if (max <= min) return;
                const range = max - min;
                const getPosition = (value) => Math.max(0, Math.min(100, ((value - min) / range) * 100));

                const card = document.createElement('div');
                card.className = 'pivot-bar-card';
                card.innerHTML = `
                    <h4 class="pivot-bar-header">${asset.pair.replace("USDT", "")} - Günlük Pivot Seviyeleri</h4>
                    <div class="pivot-bar-container">
                        <div class="pivot-bar">
                            <div class="pivot-marker" style="left: ${getPosition(s2)}%;"></div>
                            <div class="pivot-marker" style="left: ${getPosition(s1)}%;"></div>
                            <div class="pivot-marker" style="left: ${getPosition(pivot)}%;"></div>
                            <div class="pivot-marker" style="left: ${getPosition(r1)}%;"></div>
                            <div class="pivot-marker" style="left: ${getPosition(r2)}%;"></div>
                        </div>
                        <div class="current-price-indicator" style="left: ${getPosition(asset.latestPrice)}%;" data-price="${formatPrice(asset.latestPrice)}"></div>
                    </div>
                    <div class="pivot-values">
                        <span>S2: ${formatPrice(s2)}</span>
                        <span>S1: ${formatPrice(s1)}</span>
                        <span>P: ${formatPrice(pivot)}</span>
                        <span>R1: ${formatPrice(r1)}</span>
                        <span>R2: ${formatPrice(r2)}</span>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        function renderIndicatorFilters() {
            const grid = document.getElementById('crypto-indicator-filters-grid');
            if(grid) grid.innerHTML = Object.keys(AVAILABLE_INDICATORS).map(key => `<label class="filter-item"><input type="checkbox" data-indicator="${key}">${AVAILABLE_INDICATORS[key]}</label>`).join('');
        }

        function renderDictionary() {
            const content = document.getElementById('dictionaryContent');
            if(content) content.innerHTML = `<div class="dictionary-item"><h5>RSI (Göreceli Güç Endeksi)</h5><p>Fiyat hareketlerinin hızını ve değişimini ölçerek bir varlığın aşırı alım veya aşırı satım koşullarında olup olmadığını değerlendirir. 0 ile 100 arasında bir değer alır.</p><p class="example"><b>Örnek:</b> RSI değeri 70'in üzerine çıktığında, varlığın aşırı değerlendiği ve bir düzeltme (düşüş) yaşanabileceği düşünülür (Sat sinyali). 30'un altına indiğinde ise aşırı satıldığı ve bir tepki yükselişi gelebileceği düşünülür (Al sinyali).</p></div><div class="dictionary-item"><h5>MACD (Hareketli Ortalama Yakınsama/Iraksama)</h5><p>İki farklı üssel hareketli ortalama (genellikle 12 ve 26 günlük) arasındaki ilişkiyi gösteren bir trend takip ve momentum göstergesidir. MACD çizgisi, sinyal çizgisini yukarı kestiğinde al, aşağı kestiğinde sat sinyali olarak yorumlanır.</p><p class="example"><b>Örnek:</b> Mavi MACD çizgisi, turuncu sinyal çizgisini alttan yukarı doğru keserse, bu yükseliş momentumunun arttığını gösterir ve bir 'Al' fırsatı olabilir. Histogramın (çubukların) sıfır çizgisinin üzerine çıkması bu sinyali güçlendirir.</p></div><div class="dictionary-item"><h5>Hareketli Ortalamalar (EMA/SMA)</h5><p>Belirli bir periyottaki fiyatların ortalamasını alarak trend yönünü yumuşatır ve belirginleştirir. EMA (Üssel) son fiyatlara daha fazla ağırlık verirken, SMA (Basit) tüm fiyatlara eşit ağırlık verir. Kısa vadeli ortalamanın (örn. 20 EMA) uzun vadeli ortalamayı (örn. 50 EMA) yukarı kesmesi 'Golden Cross' (Al sinyali), aşağı kesmesi 'Death Cross' (Sat sinyali) olarak bilinir.</p><p class="example"><b>Örnek:</b> Fiyat grafiği 50 günlük EMA'nın üzerinde seyrediyorsa, orta vadeli trendin yükselişte olduğu kabul edilir.</p></div><div class="dictionary-item"><h5>Bollinger Bantları</h5><p>Bir basit hareketli ortalamanın (orta bant) etrafına standart sapma ile hesaplanan iki bandın (üst ve alt) eklenmesiyle oluşur. Fiyatların bu bantların dışına çıkması nadirdir ve genellikle aşırı oynaklığa veya güçlü bir trende işaret eder.</p><p class="example"><b>Örnek:</b> Fiyatlar alt banda değip tekrar içeri dönerse bu bir alım fırsatı olabilir. Fiyatların üst banda sürekli baskı yapması ve bandın genişlemesi, güçlü bir yükseliş trendinin işareti olabilir.</p></div><div class="dictionary-item"><h5>Ichimoku Cloud (Ichimoku Bulutu)</h5><p>Tek bakışta trend yönü, momentum, destek ve direnç seviyeleri hakkında kapsamlı bilgi sunar. Fiyatın bulutun (Kumo) üzerinde olması yükseliş, altında olması düşüş trendini gösterir. Bulutun kendisi ise dinamik bir destek/direnç bölgesi olarak çalışır.</p><p class="example"><b>Örnek:</b> Fiyat, yeşil bulutun üzerindeyse bu güçlü bir yükseliş trendidir. Fiyatın bulutun içine girmesi ise piyasanın kararsız olduğunu gösterir.</p></div><div class="dictionary-item"><h5>Stochastic RSI</h5><p>RSI göstergesine stokastik osilatör formülünün uygulanmasıyla elde edilir ve aşırı alım/satım sinyallerini daha sık ve net bir şekilde üretir. 80 üzeri aşırı alım, 20 altı aşırı satım olarak kabul edilir.</p><p class="example"><b>Örnek:</b> StochRSI 20 seviyesinin altına düşüp tekrar yukarı döndüğünde bu bir alım sinyali olarak değerlendirilebilir.</p></div><div class="dictionary-item"><h5>ATR (Average True Range)</h5><p>Piyasanın oynaklığını (volatilite) ölçer. Fiyatın ne kadar hareket ettiğini gösterir, ancak yönünü belirtmez. Yüksek ATR, yüksek oynaklık; düşük ATR, düşük oynaklık anlamına gelir.</p><p class="example"><b>Örnek:</b> Bir yatırımcı, stop-loss seviyesini belirlerken mevcut fiyatın 2 ATR kadar altına koyabilir. Bu, normal piyasa dalgalanmalarından etkilenmemesine yardımcı olur.</p></div><div class="dictionary-item"><h5>Fibonacci Düzeltmesi</h5><p>Bir trendin başlangıç ve bitiş noktaları arasına çizilen yatay seviyelerdir. Trendin olası geri çekilme (düzeltme) seviyelerini, yani potansiyel destek ve direnç alanlarını belirlemek için kullanılır. En yaygın seviyeler %38.2, %50 ve %61.8'dir.</p><p class="example"><b>Örnek:</b> Bir yükseliş trendinde fiyat geri çekilmeye başlarsa, yatırımcılar %50 Fibonacci seviyesinin destek olarak çalışmasını ve fiyatın buradan tekrar yükselişe geçmesini bekleyebilir.</p></div>`;
        }

       function getRecommendation(asset, activeIndicators) {
            const { indicators, latestPrice } = asset;
            let buyScore = 0, sellScore = 0;
            let summaryPoints = { buy: [], sell: [], neutral: [] };

            const formatVal = (val) => (typeof val === 'number' ? val.toFixed(2) : val);

            // --- PUANLAMA MANTIĞI ---

            // RSI
            if (activeIndicators.rsi && indicators.rsi !== null) {
                if (indicators.rsi <= 30) { buyScore += 2; summaryPoints.buy.push(`RSI(${formatVal(indicators.rsi)}) aşırı satım bölgesinde`); }
                else if (indicators.rsi < 45) { buyScore += 1; summaryPoints.buy.push(`RSI(${formatVal(indicators.rsi)}) düşük seviyede`); }
                if (indicators.rsi >= 70) { sellScore += 2; summaryPoints.sell.push(`RSI(${formatVal(indicators.rsi)}) aşırı alım bölgesinde`); }
                else if (indicators.rsi > 55) { sellScore += 1; summaryPoints.sell.push(`RSI(${formatVal(indicators.rsi)}) yüksek seviyede`); }
            }

            // Stochastic RSI
            if (activeIndicators.stochRsi && indicators.stochRsi) {
                if(indicators.stochRsi.k <= 20) { buyScore += 2; summaryPoints.buy.push(`StochRSI(${formatVal(indicators.stochRsi.k)}) aşırı satımda`); } 
                if(indicators.stochRsi.k >= 80) { sellScore += 2; summaryPoints.sell.push(`StochRSI(${formatVal(indicators.stochRsi.k)}) aşırı alımda`); }
            }
            
            // Bollinger Bands
            if (activeIndicators.bollinger && indicators.bollinger) {
                if (latestPrice < indicators.bollinger.lower) { buyScore += 2; summaryPoints.buy.push("Fiyat alt Bollinger bandının altında"); } 
                else if (latestPrice > indicators.bollinger.upper) { sellScore += 2; summaryPoints.sell.push("Fiyat üst Bollinger bandının üzerinde"); }
                else if (latestPrice < indicators.bollinger.middle) { sellScore += 0.5; } // Ortalamanın altı hafif negatif
                else if (latestPrice > indicators.bollinger.middle) { buyScore += 0.5; } // Ortalamanın üstü hafif pozitif
            }

            // MACD
            if (activeIndicators.macd && indicators.macd) {
                if (indicators.macd.histogram > 0) {
                    buyScore += 1.5;
                    summaryPoints.buy.push("MACD histogramı pozitif");
                } else {
                    sellScore += 1.5;
                    summaryPoints.sell.push("MACD histogramı negatif");
                }
            }
            
            // Moving Averages (EMA/SMA)
            if (activeIndicators.ema && activeIndicators.sma && indicators.ema && indicators.sma) {
                if (indicators.ema > indicators.sma) {
                    buyScore += 1;
                    summaryPoints.buy.push("EMA, SMA'nın üzerinde (yükseliş trendi)");
                } else {
                    sellScore += 1;
                    summaryPoints.sell.push("EMA, SMA'nın altında (düşüş trendi)");
                }
            }

            // Ichimoku Cloud
            if (activeIndicators.ichimoku && indicators.ichimoku) {
                const { tenkanSen, kijunSen, senkouSpanA, senkouSpanB } = indicators.ichimoku;
                const inCloud = latestPrice > Math.min(senkouSpanA, senkouSpanB) && latestPrice < Math.max(senkouSpanA, senkouSpanB);
                
                if (latestPrice > senkouSpanA && latestPrice > senkouSpanB) {
                    buyScore += 2;
                    summaryPoints.buy.push("Fiyat Ichimoku bulutunun üzerinde");
                } else if (latestPrice < senkouSpanA && latestPrice < senkouSpanB) {
                    sellScore += 2;
                    summaryPoints.sell.push("Fiyat Ichimoku bulutunun altında");
                } else if (inCloud) {
                    summaryPoints.neutral.push("Fiyat Ichimoku bulutunun içinde (kararsız)");
                }

                if (tenkanSen > kijunSen) { buyScore += 1; summaryPoints.buy.push("Tenkan/Kijun kesişimi pozitif"); }
                else { sellScore += 1; summaryPoints.sell.push("Tenkan/Kijun kesişimi negatif"); }
            }
            
            // Fibonacci
            if (activeIndicators.fibonacci && indicators.fibonacci) {
                if (latestPrice < indicators.fibonacci.level_618) { sellScore += 0.5; summaryPoints.sell.push("Fiyat kritik 0.618 Fibonacci desteğinin altında"); }
                else { buyScore += 0.5; summaryPoints.buy.push("Fiyat kritik 0.618 Fibonacci desteğinin üzerinde"); }
            }

            // --- KARAR MEKANİZMASI ---
            let recommendation, color, category;
            const finalScore = buyScore - sellScore;
            const conflictLevel = Math.min(buyScore, sellScore);

            // Eğer güçlü çelişki varsa (hem al hem sat sinyalleri güçlüyse) TUT tavsiyesi verilir.
            if (conflictLevel >= 3) {
                recommendation = "Tut";
                color = "var(--hold)";
                category = "hold";
            } else {
                if (finalScore >= 4) { recommendation = "Güçlü Al"; color = "var(--strong-buy)"; category = "buy"; }
                else if (finalScore >= 1.5) { recommendation = "Al"; color = "var(--buy)"; category = "buy"; }
                else if (finalScore <= -4) { recommendation = "Güçlü Sat"; color = "var(--strong-sell)"; category = "sell"; }
                else if (finalScore <= -1.5) { recommendation = "Sat"; color = "var(--sell)"; category = "sell"; }
                else { recommendation = "Tut"; color = "var(--hold)"; category = "hold"; }
            }

            // --- ÖZET OLUŞTURMA ---
            let summary = "";
            if (summaryPoints.buy.length > 0) {
                summary += `<b>⬆ Al Sinyalleri (${summaryPoints.buy.length}):</b> ${summaryPoints.buy.join(', ')}. `;
            }
            if (summaryPoints.sell.length > 0) {
                summary += `<br><b>⬇ Sat Sinyalleri (${summaryPoints.sell.length}):</b> ${summaryPoints.sell.join(', ')}. `;
            }
            if (summaryPoints.neutral.length > 0) {
                 summary += `<br><b>➖ Nötr Sinyaller (${summaryPoints.neutral.length}):</b> ${summaryPoints.neutral.join(', ')}.`;
            }
            if (summary.length === 0) {
                summary = "Aktif indikatörlere göre belirgin bir sinyal bulunamadı.";
            }


            return { recommendation, color, summary, category };
        }

        function renderIndicatorCards(type) {
            const container = document.getElementById('crypto-indicator-cards-container');
            container.innerHTML = '';
            const activeIndicators = settings[`${type}AnalysisIndicators`];

            allCryptoData.forEach(asset => {
                if (currentRecommendationFilter !== 'all' && asset.recommendationCategory !== currentRecommendationFilter) {
                    return;
                }

                const card = document.createElement('div');
                card.className = 'indicator-card';
                if (asset.error) {
                    card.innerHTML = `<h4>${asset.pair.replace("USDT", "")}</h4><p style="color:var(--accent-red)">Veri yüklenemedi.</p>`;
                    container.appendChild(card);
                    return;
                }
                const { recommendation, recommendationColor, recommendationSummary, latestPrice, indicators } = asset;

                const getValueHTML = (label, value, formatter, positiveCondition, negativeCondition) => {
                    if (value === null || value === undefined) return '';
                    let className = 'value';
                    if (positiveCondition?.(value)) className += ' value-positive';
                    else if (negativeCondition?.(value)) className += ' value-negative';
                    return `<div class="indicator-item"><span class="label">${label}</span><span class="${className}">${formatter(value)}</span></div>`;
                };

                let detailsHTML = '<div class="indicator-details-grid">';
                detailsHTML += getValueHTML('Fiyat', latestPrice, val => `$${formatPrice(val)}`);
                Object.keys(AVAILABLE_INDICATORS).forEach(key => {
                    if(activeIndicators[key]) {
                        const indicatorValue = indicators[key];
                        if (indicatorValue !== undefined && indicatorValue !== null) {
                             switch(key) {
                                case 'rsi': detailsHTML += getValueHTML('RSI', indicatorValue, v => v.toFixed(2), v => v < 30, v => v > 70); break;
                                case 'macd': detailsHTML += getValueHTML('MACD Hist.', indicatorValue?.histogram, v => v.toFixed(6), v => v > 0, v => v < 0); break;
                                case 'stochRsi': detailsHTML += getValueHTML('Stoch RSI (k)', indicatorValue?.k, v => v.toFixed(2), v => v < 20, v => v > 80); break;
                                case 'volume': detailsHTML += getValueHTML('Hacim (24s)', indicatorValue, formatVolume); break;
                                case 'ema': detailsHTML += getValueHTML('EMA (50)', indicatorValue, v => v.toFixed(2)); break;
                                case 'sma': detailsHTML += getValueHTML('SMA (50)', indicatorValue, v => v.toFixed(2)); break;
                                case 'atr': detailsHTML += getValueHTML('ATR', indicatorValue, v => v.toFixed(4)); break;
                                case 'bollinger': 
                                    detailsHTML += getValueHTML('Bollinger Üst', indicatorValue?.upper, v => v.toFixed(2));
                                    detailsHTML += getValueHTML('Bollinger Orta', indicatorValue?.middle, v => v.toFixed(2));
                                    detailsHTML += getValueHTML('Bollinger Alt', indicatorValue?.lower, v => v.toFixed(2));
                                    break;
                                case 'ichimoku': 
                                    detailsHTML += getValueHTML('Ichimoku Tenkan', indicatorValue?.tenkanSen, v => v.toFixed(2)); 
                                    detailsHTML += getValueHTML('Ichimoku Kijun', indicatorValue?.kijunSen, v => v.toFixed(2)); 
                                    detailsHTML += getValueHTML('Ichimoku Senkou A', indicatorValue?.senkouSpanA, v => v.toFixed(2)); 
                                    detailsHTML += getValueHTML('Ichimoku Senkou B', indicatorValue?.senkouSpanB, v => v.toFixed(2)); 
                                    break;
                                case 'fibonacci': 
                                    detailsHTML += getValueHTML('Fib 0.236', indicatorValue?.level_236, v => v.toFixed(2)); 
                                    detailsHTML += getValueHTML('Fib 0.382', indicatorValue?.level_382, v => v.toFixed(2)); 
                                    detailsHTML += getValueHTML('Fib 0.5', indicatorValue?.level_500, v => v.toFixed(2)); 
                                    detailsHTML += getValueHTML('Fib 0.618', indicatorValue?.level_618, v => v.toFixed(2)); 
                                    break;
                            }
                        }
                    }
                });
                detailsHTML += '</div>';

                let aiButtonHTML = '';
                if (currentUserRole === 'admin') {
                    aiButtonHTML = `<button class="ai-btn" data-pair="${asset.pair}" data-type="${type}" title="Bu varlığı yorumla"><i class="fas fa-magic-sparkles"></i></button>`;
                }

                card.innerHTML = `
                    <div class="indicator-card-header">
                        <h4>${asset.pair.replace("USDT", "")}</h4>
                        <span class="recommendation-badge" style="background-color:${recommendationColor};">${recommendation}</span>
                    </div>
                    ${detailsHTML}
                    <div class="card-footer">
                        <div class="summary">${recommendationSummary}</div>
                        ${aiButtonHTML}
                    </div>`;
                container.appendChild(card);
            });
        }

        async function getGeminiAnalysis(type, pair = null) {
            const button = pair ? document.querySelector(`.ai-btn[data-pair="${pair}"]`) : document.getElementById(`analyzeAllCryptoBtn`);
            if (!button) return;

            showLoading(button);
            const analysisContent = document.getElementById('analysisContent');
            analysisContent.innerHTML = '<div class="loading" style="margin: 20px auto; display:block;"></div>';
            showPanel('analysisPanel');

            const dataToAnalyze = (pair ? allCryptoData.filter(c => c.pair === pair) : allCryptoData);
            const activeIndicators = settings[`${type}AnalysisIndicators`];
            let dataSummary = "";

            dataToAnalyze.forEach(asset => {
                if(!asset.error) {
                    dataSummary += `Varlık: ${asset.pair.replace('USDT', '')}, Fiyat: ${formatPrice(asset.latestPrice)}. Aktif indikatörler: `;
                    Object.keys(activeIndicators).forEach(key => {
                        if(activeIndicators[key] && asset.indicators[key] !== null && asset.indicators[key] !== undefined) {
                             let val = asset.indicators[key];
                             if(typeof val === 'object') val = JSON.stringify(val, (k,v) => typeof v === 'number' ? parseFloat(v.toFixed(4)) : v);
                             dataSummary += `${key}: ${val}, `;
                        }
                    });
                    dataSummary += "\n";
                }
            });
            
            try {
                const geminiProxy = functions.httpsCallable('geminiProxy');
                const result = await geminiProxy({ prompt: dataSummary });

                if (result.data && result.data.analysis) {
                    const cleanedHtml = result.data.analysis.replace(/^```html\n?|```$/g, '');
                    analysisContent.innerHTML = cleanedHtml;
                } else {
                    throw new Error("Yapay zekadan geçerli bir yanıt alınamadı.");
                }
            } catch (error) {
                console.error("Gemini AI Hatası:", error);
                analysisContent.innerHTML = `<p style="color:var(--accent-red)">Yorumlama sırasında bir hata oluştu: ${error.message}. Lütfen Firebase projenizde 'geminiProxy' adlı Cloud Function'ın doğru şekilde deploy edildiğinden ve faturalandırmanın aktif olduğundan emin olun.</p>`;
            } finally {
                hideLoading(button);
            }
        }

        const addNewAsset = async (type) => {
            const input = document.getElementById('newCoinInput');
            const assetList = cryptoPairs;
            const limit = coinLimit;
            const saveFunction = saveCryptoPairsToFirestore;

            const newAssetSymbols = input.value.split(',').map(s => s.trim().toUpperCase()).filter(Boolean);
            if (newAssetSymbols.length === 0) return;
            if (limit !== Infinity && (assetList.length + newAssetSymbols.length) > limit) {
                showNotification(translations[settings.lang].role_info(currentUserRole, limit, 'coin'), false);
                return;
            }

            for (const symbol of newAssetSymbols) {
                const newPair = (type === 'crypto' && !symbol.endsWith('USDT')) ? `${symbol}USDT` : symbol;
                if (assetList.includes(newPair)) {
                    showNotification(translations[settings.lang].already_in_list(symbol), false);
                    continue;
                }
                try {
                    await axios.get(`https://api.binance.com/api/v3/ticker/price?symbol=${newPair}`);
                    assetList.push(newPair);
                } catch (error) {
                    showNotification(translations[settings.lang].invalid_asset(symbol), false);
                }
            }
            saveFunction();
            fetchAllDataAndRender();
            input.value = '';
        };

        function showChart(pair, type) {
            document.getElementById('chartPanelTitle').textContent = pair.replace("USDT", "");
            document.getElementById('chartContainer').innerHTML = '';
            new TradingView.widget({ "autosize": true, "symbol": `BINANCE:${pair}`, "interval": "D", "theme": "dark", "style": "1", "locale": settings.lang, "container_id": "chartContainer" });
            showPanel('chartPanel');
        }

        // --- EVENT LISTENERS ---
        document.getElementById('logoutBtn').addEventListener('click', (e) => { e.preventDefault(); auth.signOut(); });
        document.getElementById('refreshBtn').addEventListener('click', fetchAllDataAndRender);
        document.getElementById('addCoinBtn').addEventListener('click', () => addNewAsset('crypto'));
        document.getElementById('newCoinInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') addNewAsset('crypto'); });
        document.getElementById('settingsBtn').addEventListener('click', () => showPanel('settingsPanel'));
        document.querySelectorAll('.close-btn').forEach(btn => btn.addEventListener('click', closeAllPanels));
        document.getElementById('saveSettingsBtn').addEventListener('click', saveSettings);
        modalOverlay.addEventListener('click', closeAllPanels);
        document.getElementById('toggleSortBtn').addEventListener('click', () => {
            document.querySelectorAll('.drag-handle-col').forEach(el => el.classList.toggle('hidden'));
        });
        document.querySelector('#crypto-content thead').addEventListener('click', (e) => {
            const header = e.target.closest('th.sortable');
            if (!header) return;

            const key = header.dataset.sortKey;
            
            if (currentSort.key !== key) {
                currentSort.key = key;
                currentSort.order = 'asc';
            } else {
                if (currentSort.order === 'asc') {
                    currentSort.order = 'desc';
                } else if (currentSort.order === 'desc') {
                    currentSort.key = null;
                    currentSort.order = 'default';
                }
            }
            sortAndRenderTable();
        });


        trackerPage.addEventListener('click', (e) => {
            const collapsibleHeader = e.target.closest('.collapsible-header');
            if (collapsibleHeader) { 
                collapsibleHeader.classList.toggle('open'); 
                const content = collapsibleHeader.nextElementSibling;
                if(content?.classList.contains('collapsible-content')) {
                    content.classList.toggle('open');
                }
                return; 
            }

            const tabLink = e.target.closest('.tab-link');
            if(tabLink && !tabLink.classList.contains('active')) {
                document.querySelector('.tab-link.active')?.classList.remove('active');
                document.querySelector('.tab-content.active')?.classList.remove('active');
                tabLink.classList.add('active');
                document.getElementById(`${tabLink.dataset.tab}-content`)?.classList.add('active');
                return;
            }

            const assetActionTarget = e.target.closest('.asset-cell, .clickable-pct, .remove-btn');
            if(assetActionTarget) {
                const { pair, type, col } = assetActionTarget.dataset;
                if (!pair) return;
                const assetData = allCryptoData.find(c => c.pair === pair);

                if (assetActionTarget.classList.contains('asset-cell')) { 
                    showChart(pair, type); 
                }
                else if (assetActionTarget.classList.contains('clickable-pct')) {
                    if (assetData && !assetData.error) {
                        const colData = assetData[`col${col}`];
                        if (colData && colData.lowestPrice) {
                            const periodName = settings.columns[col].name;
                            const pctChange = colData.pct.toFixed(2);
                            
                            document.getElementById('detailPanelTitle').textContent = `${assetData.pair.replace('USDT','')} - ${periodName} Değişim Detayı`;
                            document.getElementById('detailPanelContent').innerHTML = translations[settings.lang].lowest_price_detail(
                                periodName,
                                formatPrice(colData.lowestPrice), 
                                colData.lowestDate,
                                formatPrice(assetData.latestPrice),
                                pctChange
                            );
                            showPanel('detailPanel');
                        }
                    }
                } else if (assetActionTarget.classList.contains('remove-btn')) {
                    cryptoPairs = cryptoPairs.filter(p => p !== pair);
                    saveCryptoPairsToFirestore();
                    fetchAllDataAndRender();
                }
            }

            const pivotFilterBtn = e.target.closest('#cryptoPivotFilters button');
            if(pivotFilterBtn) {
                 settings.cryptoPivotFilter = pivotFilterBtn.dataset.filter;
                 if (userDocRef) userDocRef.update({ 'settings.cryptoPivotFilter': settings.cryptoPivotFilter });
                 document.querySelector('#cryptoPivotFilters button.active').classList.remove('active');
                 pivotFilterBtn.classList.add('active');
                 renderSupportResistance('crypto', allCryptoData);
                 return;
            }
            const intervalFilterBtn = e.target.closest('#cryptoIntervalFilters button');
            if(intervalFilterBtn && !intervalFilterBtn.classList.contains('active')) {
                document.querySelector('#cryptoIntervalFilters button.active').classList.remove('active');
                intervalFilterBtn.classList.add('active');
                // No automatic refresh here, user must click "Update Analysis"
                return;
            }
             const recommendationFilterBtn = e.target.closest('#cryptoRecommendationFilters button');
            if(recommendationFilterBtn) {
                 currentRecommendationFilter = recommendationFilterBtn.dataset.filter;
                 document.querySelector('#cryptoRecommendationFilters button.active').classList.remove('active');
                 recommendationFilterBtn.classList.add('active');
                 renderIndicatorCards('crypto');
                 return;
            }
        });

        document.getElementById('updateCryptoAnalysisBtn').addEventListener('click', () => updateAnalysisSettings('crypto'));
        document.getElementById('analyzeAllCryptoBtn').addEventListener('click', () => getGeminiAnalysis('crypto'));
        document.getElementById('crypto-indicator-cards-container').addEventListener('click', (e) => {
            const target = e.target.closest('.ai-btn');
            if (target) getGeminiAnalysis(target.dataset.type, target.dataset.pair);
        });

        sortableInstance = new Sortable(document.getElementById('cryptoPriceTable'), {
            handle: '.drag-handle',
            animation: 150,
            onEnd: (evt) => {
                const [movedItem] = cryptoPairs.splice(evt.oldIndex, 1);
                cryptoPairs.splice(evt.newIndex, 0, movedItem);
                saveCryptoPairsToFirestore();
            }
        });

        renderIndicatorFilters();
        renderDictionary();
        loadSettings(userData);
        await fetchAllDataAndRender();
        updateAdminUI();
    }
</script>

</body>
</html>
